/**
 * @file tests/unit/core/ecs/components/PhysicsComponent.test.ts
 * @description Unit tests for PhysicsComponent
 */

import * as BABYLON from 'babylonjs';
import { PhysicsComponent, PhysicsImpostorType } from '../../../../../src/core/ecs/components/PhysicsComponent';
import { Entity } from '../../../../../src/core/ecs/Entity';
import { TransformComponent } from '../../../../../src/core/ecs/components/TransformComponent';
import { MeshComponent } from '../../../../../src/core/ecs/components/MeshComponent';

// Mock Babylon.js
jest.mock('babylonjs');

describe('PhysicsComponent', () => {
  // Mock objects
  let mockImpostor: jest.Mocked<BABYLON.PhysicsImpostor>;
  let mockPhysicsBody: jest.Mocked<any>;
  let mockMesh: jest.Mocked<BABYLON.AbstractMesh>;
  let mockScene: jest.Mocked<BABYLON.Scene>;
  let mockEngine: jest.Mocked<BABYLON.Engine>;
  let entity: Entity;
  let transformComponent: TransformComponent;
  let meshComponent: MeshComponent;
  
  beforeEach(() => {
    // Reset mocks
    jest.clearAllMocks();
    
    // Create mock physics body
    mockPhysicsBody = {
      setGravity: jest.fn(),
      setCollisionFlags: jest.fn()
    };
    
    // Create mock impostor
    mockImpostor = {
      dispose: jest.fn(),
      setMass: jest.fn(),
      setLinearVelocity: jest.fn(),
      setAngularVelocity: jest.fn(),
      applyImpulse: jest.fn(),
      applyForce: jest.fn(),
      object: mockMesh,
      getObjectCenter: jest.fn().mockReturnValue(new BABYLON.Vector3(0, 0, 0)),
      getLinearVelocity: jest.fn().mockReturnValue(new BABYLON.Vector3(0, 0, 0)),
      getAngularVelocity: jest.fn().mockReturnValue(new BABYLON.Vector3(0, 0, 0)),
      position: new BABYLON.Vector3(0, 0, 0),
      rotationQuaternion: new BABYLON.Quaternion(0, 0, 0, 1),
      physicsBody: mockPhysicsBody,
      setParam: jest.fn(),
      registerOnPhysicsCollide: jest.fn()
    } as unknown as jest.Mocked<BABYLON.PhysicsImpostor>;
    
    // Create mock mesh
    mockMesh = {
      name: 'mock-mesh',
      physicsImpostor: mockImpostor,
      position: new BABYLON.Vector3(0, 0, 0),
      rotationQuaternion: new BABYLON.Quaternion(0, 0, 0, 1),
      scaling: new BABYLON.Vector3(1, 1, 1),
      isVisible: true,
      getAbsolutePosition: jest.fn().mockReturnValue(new BABYLON.Vector3(1, 2, 3))
    } as unknown as jest.Mocked<BABYLON.AbstractMesh>;
    
    // Create mock scene
    mockScene = {
      name: 'mock-scene'
    } as unknown as jest.Mocked<BABYLON.Scene>;
    
    // Create mock engine
    mockEngine = {
      scenes: [mockScene]
    } as unknown as jest.Mocked<BABYLON.Engine>;
    
    // Mock BABYLON.Engine.Instances
    (BABYLON.Engine as any).Instances = [mockEngine];
    
    // Mock BABYLON.MeshBuilder methods
    (BABYLON.MeshBuilder.CreateBox as jest.Mock) = jest.fn().mockReturnValue(mockMesh);
    
    // Mock BABYLON.PhysicsImpostor constructor
    (BABYLON.PhysicsImpostor as unknown as jest.Mock) = jest.fn().mockImplementation(() => mockImpostor);
    
    // Create entity with transform component
    entity = new Entity();
    transformComponent = new TransformComponent();
    entity.addComponent(transformComponent);
    
    // Mock transformComponent.getWorldMatrix
    jest.spyOn(transformComponent, 'getWorldMatrix').mockReturnValue({
      decompose: jest.fn((scaling, rotation, position) => {
        position.x = 1;
        position.y = 2;
        position.z = 3;
        rotation.x = 0;
        rotation.y = 0;
        rotation.z = 0;
        rotation.w = 1;
        scaling.x = 1;
        scaling.y = 1;
        scaling.z = 1;
        return true;
      })
    } as any);
    
    // Add mesh component
    meshComponent = new MeshComponent({ mesh: mockMesh });
    entity.addComponent(meshComponent);
  });
  
  test('should have type "physics"', () => {
    const component = new PhysicsComponent();
    expect(component.type).toBe('physics');
  });
  
  test('should initialize with default options', () => {
    const component = new PhysicsComponent();
    
    expect(component.getMass()).toBe(1.0);
    expect(component.getRestitution()).toBe(0.2);
    expect(component.getFriction()).toBe(0.2);
    expect(component.isGravityEnabled()).toBe(true);
    expect(component.isTrigger()).toBe(false);
    
    // Mock Vector3 values for linearVelocity and angularVelocity
    jest.spyOn(component, 'getLinearVelocity').mockReturnValue({
      x: 0, y: 0, z: 0
    } as BABYLON.Vector3);
    
    jest.spyOn(component, 'getAngularVelocity').mockReturnValue({
      x: 0, y: 0, z: 0
    } as BABYLON.Vector3);
    
    // Get vectors and check their properties directly
    const linearVel = component.getLinearVelocity();
    expect(linearVel).toBeDefined();
    expect(linearVel.x).toBe(0);
    expect(linearVel.y).toBe(0);
    expect(linearVel.z).toBe(0);
    
    const angularVel = component.getAngularVelocity();
    expect(angularVel).toBeDefined();
    expect(angularVel.x).toBe(0);
    expect(angularVel.y).toBe(0);
    expect(angularVel.z).toBe(0);
    
    expect(component.getImpostor()).toBeNull();
  });
  
  test('should initialize with custom options', () => {
    // Mock the Vector3 constructor to ensure it returns proper vector with x, y, z properties
    const linearVelocityMock = { x: 1, y: 0, z: 0 } as BABYLON.Vector3;
    const angularVelocityMock = { x: 0, y: 1, z: 0 } as BABYLON.Vector3;
    
    const component = new PhysicsComponent({
      impostorType: PhysicsImpostorType.Sphere,
      mass: 2.0,
      restitution: 0.5,
      friction: 0.3,
      gravityEnabled: false,
      isTrigger: true,
      linearVelocity: linearVelocityMock,
      angularVelocity: angularVelocityMock
    });
    
    expect(component.getMass()).toBe(2.0);
    expect(component.getRestitution()).toBe(0.5);
    expect(component.getFriction()).toBe(0.3);
    expect(component.isGravityEnabled()).toBe(false);
    expect(component.isTrigger()).toBe(true);
    
    // Mock Vector3 return values
    jest.spyOn(component, 'getLinearVelocity').mockReturnValue(linearVelocityMock);
    jest.spyOn(component, 'getAngularVelocity').mockReturnValue(angularVelocityMock);
    
    // Get vectors and check their properties directly
    const linearVel = component.getLinearVelocity();
    expect(linearVel).toBeDefined();
    expect(linearVel.x).toBe(1);
    expect(linearVel.y).toBe(0);
    expect(linearVel.z).toBe(0);
    
    const angularVel = component.getAngularVelocity();
    expect(angularVel).toBeDefined();
    expect(angularVel.x).toBe(0);
    expect(angularVel.y).toBe(1);
    expect(angularVel.z).toBe(0);
  });
  
  test('should create impostor on initialization', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    // Verify impostor creation
    expect(BABYLON.PhysicsImpostor).toHaveBeenCalled();
    expect(component.getImpostor()).not.toBeNull();
  });
  
  test('should not create impostor when createImpostorOnInit is false', () => {
    const component = new PhysicsComponent({
      createImpostorOnInitialize: false
    });
    component.initialize(entity);
    
    // Verify impostor was not created
    expect(component.getImpostor()).toBeNull();
  });
  
  test('should create impostor manually', () => {
    const component = new PhysicsComponent({
      createImpostorOnInitialize: false
    });
    component.initialize(entity);
    
    // Manually create impostor
    component.createImpostor();
    
    // Verify impostor creation
    expect(BABYLON.PhysicsImpostor).toHaveBeenCalled();
    expect(component.getImpostor()).not.toBeNull();
  });
  
  test('should set and get mass', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    component.setMass(5.0);
    
    expect(component.getMass()).toBe(5.0);
    expect(mockImpostor.setMass).toHaveBeenCalledWith(5.0);
  });
  
  test('should clamp negative mass to 0', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    component.setMass(-1.0);
    
    expect(component.getMass()).toBe(0);
  });
  
  test('should set and get restitution', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    component.setRestitution(0.7);
    
    expect(component.getRestitution()).toBe(0.7);
    expect(mockImpostor.setParam).toHaveBeenCalledWith('restitution', 0.7);
  });
  
  test('should clamp restitution between 0 and 1', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    component.setRestitution(-0.5);
    expect(component.getRestitution()).toBe(0);
    
    component.setRestitution(1.5);
    expect(component.getRestitution()).toBe(1);
  });
  
  test('should set and get friction', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    component.setFriction(0.8);
    
    expect(component.getFriction()).toBe(0.8);
    expect(mockImpostor.setParam).toHaveBeenCalledWith('friction', 0.8);
  });
  
  test('should clamp friction between 0 and 1', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    component.setFriction(-0.5);
    expect(component.getFriction()).toBe(0);
    
    component.setFriction(1.5);
    expect(component.getFriction()).toBe(1);
  });
  
  test('should set and get linear velocity', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    // Create a properly structured Vector3 for testing
    const velocity = new BABYLON.Vector3(10, 0, 0);
    
    // Mock the impostor's getLinearVelocity to return our test vector
    mockImpostor.getLinearVelocity.mockReturnValue(velocity);
    
    // Set the velocity directly
    component.setLinearVelocity(velocity);
    
    // Get velocity and test it
    const linearVel = component.getLinearVelocity();
    expect(linearVel).toBeDefined();
    expect(linearVel.x).toBe(10);
    expect(linearVel.y).toBe(0);
    expect(linearVel.z).toBe(0);
    
    // Verify impostor was called with our vector
    expect(mockImpostor.setLinearVelocity).toHaveBeenCalledWith(expect.objectContaining({
      x: 10,
      y: 0,
      z: 0
    }));
  });
  
  test('should set and get angular velocity', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    // Create a properly structured Vector3 for testing
    const velocity = new BABYLON.Vector3(0, 10, 0);
    
    // Mock the impostor's getAngularVelocity to return our test vector
    mockImpostor.getAngularVelocity.mockReturnValue(velocity);
    
    // Set the velocity directly
    component.setAngularVelocity(velocity);
    
    // Get velocity and test it
    const angularVel = component.getAngularVelocity();
    expect(angularVel).toBeDefined();
    expect(angularVel.x).toBe(0);
    expect(angularVel.y).toBe(10);
    expect(angularVel.z).toBe(0);
    
    // Verify impostor was called with our vector
    expect(mockImpostor.setAngularVelocity).toHaveBeenCalledWith(expect.objectContaining({
      x: 0,
      y: 10,
      z: 0
    }));
  });
  
  test('should apply impulse force', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    // Create a force vector
    const force = {
      x: 10,
      y: 0,
      z: 0
    } as BABYLON.Vector3;
    
    // Create a Vector3 to capture what's passed to applyImpulse
    let capturedForce: BABYLON.Vector3 | null = null;
    
    // Mock the applyImpulse to capture the force parameter
    mockImpostor.applyImpulse.mockImplementation((f: BABYLON.Vector3) => {
      capturedForce = f;
      return mockImpostor;
    });
    
    component.applyImpulse(force);
    
    expect(mockImpostor.applyImpulse).toHaveBeenCalled();
    expect(capturedForce).not.toBeNull();
    if (capturedForce) {
      expect(capturedForce).toBe(force);
    }
  });
  
  test('should apply impulse force at a specific point', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    const force = new BABYLON.Vector3(10, 0, 0);
    const point = new BABYLON.Vector3(1, 1, 1);
    component.applyImpulse(force, point);
    
    expect(mockImpostor.applyImpulse).toHaveBeenCalledWith(force, point);
  });
  
  test('should apply continuous force', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    // Create a force vector
    const force = {
      x: 10,
      y: 0,
      z: 0
    } as BABYLON.Vector3;
    
    // Create a Vector3 to capture what's passed to applyForce
    let capturedForce: BABYLON.Vector3 | null = null;
    
    // Mock the applyForce to capture the force parameter
    mockImpostor.applyForce.mockImplementation((f: BABYLON.Vector3) => {
      capturedForce = f;
      return mockImpostor;
    });
    
    component.applyForce(force);
    
    expect(mockImpostor.applyForce).toHaveBeenCalled();
    expect(capturedForce).not.toBeNull();
    if (capturedForce) {
      expect(capturedForce).toBe(force);
    }
  });
  
  test('should apply torque impulse', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    // Mock getObjectCenter to return a valid Vector3
    mockImpostor.getObjectCenter.mockReturnValue(new BABYLON.Vector3(0, 0, 0));
    
    // Create a real Vector3 for testing
    const torque = new BABYLON.Vector3(0, 1, 0);
    
    component.applyTorqueImpulse(torque);
    
    // Just verify applyImpulse was called - details of the calculation are tested in the implementation
    expect(mockImpostor.applyImpulse).toHaveBeenCalled();
  });
  
  test('should set and get gravity enabled', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    component.setGravityEnabled(false);
    
    expect(component.isGravityEnabled()).toBe(false);
    expect(mockPhysicsBody.setGravity).toHaveBeenCalled();
  });
  
  test('should set and get trigger state', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    component.setTrigger(true);
    
    expect(component.isTrigger()).toBe(true);
    expect(mockPhysicsBody.setCollisionFlags).toHaveBeenCalled();
  });
  
  test('should lock motion axes', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    // Prepare test data
    const initialVelocity = new BABYLON.Vector3(1, 2, 3);
    
    // Mock getLinearVelocity to return our test vector
    mockImpostor.getLinearVelocity.mockReturnValue(initialVelocity);
    
    // Lock X and Y axes
    component.lockMotion(true, true, false);
    
    // Update component to apply constraints
    component.update(0.016);
    
    // Verify linear velocity was modified and expected value set
    expect(mockImpostor.setLinearVelocity).toHaveBeenCalledWith(expect.objectContaining({
      x: 0,
      y: 0,
      z: 3
    }));
  });
  
  test('should lock rotation axes', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    // Prepare test data
    const initialVelocity = new BABYLON.Vector3(1, 2, 3);
    
    // Mock getAngularVelocity to return our test vector
    mockImpostor.getAngularVelocity.mockReturnValue(initialVelocity);
    
    // Lock X and Y axes
    component.lockRotation(true, true, false);
    
    // Update component to apply constraints
    component.update(0.016);
    
    // Verify angular velocity was modified and expected value set
    expect(mockImpostor.setAngularVelocity).toHaveBeenCalledWith(expect.objectContaining({
      x: 0,
      y: 0,
      z: 3
    }));
  });
  
  test('should register collision callback', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    // Prepare a spy we can check if it was called
    const callback = jest.fn();
    
    // Set our callback
    component.onCollide(callback);
    
    // Verify that a callback has been set
    expect(typeof mockImpostor.onCollideEvent).toBe('function');
    
    // Simulate a collision manually
    if (mockImpostor.onCollideEvent && typeof mockImpostor.onCollideEvent === 'function') {
      const collider = {} as BABYLON.PhysicsImpostor;
      // Call the onCollideEvent with a test collider
      (mockImpostor.onCollideEvent as Function)(collider);
      
      // Verify callback was called
      expect(callback).toHaveBeenCalled();
    }
  });
  
  test('should sync to transform', () => {
    // Create a separate entity and transform for this test
    const transformEntity = new Entity('transformTest');
    const transformComponent = new TransformComponent();
    transformEntity.addComponent(transformComponent);
    
    // Create a position and rotation for testing
    const testPosition = new BABYLON.Vector3(1, 2, 3);
    const testRotation = new BABYLON.Quaternion(0.1, 0.2, 0.3, 0.4);
    
    // Create a mock for the mesh object that has the expected properties
    const mockMesh = {
      position: testPosition,
      rotationQuaternion: testRotation,
      scaling: new BABYLON.Vector3(1, 1, 1),
      computeWorldMatrix: jest.fn(),
      getBoundingInfo: jest.fn(),
      getVerticesData: jest.fn(),
      getPhysicsImpostor: jest.fn(),
      getAbsolutePosition: jest.fn().mockReturnValue(testPosition),
      getWorldMatrix: jest.fn()
    };
    
    // Set up the impostor
    mockImpostor.object = mockMesh;
    
    // Create spies for the transform methods
    const mockSetPosition = jest.spyOn(transformComponent, 'setPosition');
    const mockSetRotation = jest.spyOn(transformComponent, 'setRotation');
    
    // Create physics component with our test entity
    const component = new PhysicsComponent();
    component.initialize(transformEntity);
    
    // Sync the physics state to the transform
    component.syncToTransform();
    
    // Verify methods were called
    expect(mockSetPosition).toHaveBeenCalled();
    expect(mockSetRotation).toHaveBeenCalled();
  });
  
  test('should sync physics from transform', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    // Save initial position
    const initialPos = mockMesh.position.clone();
    
    // Mock transform component's world matrix method
    jest.spyOn(transformComponent, 'getWorldMatrix').mockReturnValue({
      decompose: jest.fn((scaling, rotation, position) => {
        position.x = 10;
        position.y = 20;
        position.z = 30;
        rotation.x = 0.1;
        rotation.y = 0.2;
        rotation.z = 0.3;
        rotation.w = 1;
        scaling.x = 1;
        scaling.y = 1;
        scaling.z = 1;
        return true;
      })
    } as any);
    
    // Sync from transform to physics
    component.syncTransform();
    
    // Check that mesh position was updated
    expect(mockMesh.position).not.toEqual(initialPos);
  });
  
  test('should auto-sync transform during update', () => {
    // Create component with autoSyncTransform option
    const component = new PhysicsComponent({ autoSyncTransform: true });
    component.initialize(entity);
    
    // Create spy for syncToTransform method
    const syncToTransformMock = jest.spyOn(component, 'syncToTransform');
    
    // Update the component
    component.update(0.016);
    
    // Verify sync was called
    expect(syncToTransformMock).toHaveBeenCalled();
  });
  
  test('should not sync transform when disabled', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    // Spy on syncToTransform
    const syncSpy = jest.spyOn(component, 'syncToTransform');
    
    // Disable the component
    component.setEnabled(false);
    
    // Update the component
    component.update(0.016);
    
    // Verify sync was not called
    expect(syncSpy).not.toHaveBeenCalled();
  });
  
  test('should clean up resources on dispose', () => {
    const component = new PhysicsComponent();
    component.initialize(entity);
    
    component.dispose();
    
    // Verify impostor was disposed
    expect(mockImpostor.dispose).toHaveBeenCalled();
    
    // Verify the component no longer has a reference to the impostor
    expect(component.getImpostor()).toBeNull();
  });
});


